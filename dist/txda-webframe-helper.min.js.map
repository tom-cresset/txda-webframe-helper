{
  "version": 3,
  "sources": ["../src/index.ts", "../src/handlers.ts"],
  "sourcesContent": ["import { attachHandlers } from \"./handlers\"\nimport { TXDAConnection, TXDAMessageHandlers } from \"./types\"\n\nconst initialize = (origin: string, handlers: TXDAMessageHandlers = {}): Promise<TXDAConnection> =>\n  new Promise((resolve, reject) => {\n    if (origin === '*') {\n      reject('Specific target origins must be specified to connect to TXDA installs')\n      return\n    }\n\n    // Listen for events from TXDA for initial setup of MessagePort\n    window.addEventListener('message', windowEvent => {\n      if (windowEvent.data?.messageType === 'txdaMessagePortTransfer') {\n        if (windowEvent.origin !== origin) {\n          reject('Attempted TXDA connection event from unauthorized origin')\n          return\n        }\n\n        const port = windowEvent.ports[0]\n\n        // Add any given event handlers to the port\n        attachHandlers(port, handlers)\n\n        port.start()\n\n        // Fire an initial request for the current design as soon as the port starts\n        port.postMessage({ messageType: 'txdaRequestCurrentDesign' })\n\n        const txdaConnection: TXDAConnection = {\n          port,\n          requestCurrentDesign: () => port.postMessage({\n            messageType: 'txdaRequestCurrentDesign'\n          }),\n          disconnect: () => port.close()\n        }\n\n        resolve(txdaConnection)\n      }\n    })\n\n    window.parent.postMessage({\n      messageType: 'txdaConnectionRequest',\n      windowName: window.name,\n    }, origin)\n\n    // If there's no response from TXDA, reject\n    setTimeout(() => {\n      reject('Connection to TXDA failed (timed out)')\n    }, 10000)\n  })\n\nexport { initialize }\n", "import { TXDAMessageHandlers } from \"./types\"\n\nexport const attachHandlers = (port: MessagePort, handlers: TXDAMessageHandlers) => {\n  if (handlers._message) {\n    port.addEventListener('message', portEvent => {\n      handlers._message?.(portEvent)\n    })\n  }\n\n  if (handlers.connectionEstablished) {\n    port.addEventListener('message', portEvent => {\n      if (portEvent.data?.messageType === 'txdaConnectionAcknowledgement') {\n        handlers.connectionEstablished?.()\n      }\n    })\n  }\n\n  if (handlers.updateCurrentDesign) {\n    port.addEventListener('message', portEvent => {\n      if (portEvent.data?.messageType === 'txdaCurrentDesign') {\n        const {\n          metaData,\n          data: currentDesign\n        } = portEvent.data\n        handlers.updateCurrentDesign?.(currentDesign, metaData)\n      }\n    })\n  }\n}\n"],
  "mappings": "kKAAA,iCCEO,GAAM,GAAiB,CAAC,EAAmB,IAAkC,CAClF,AAAI,EAAS,UACX,EAAK,iBAAiB,UAAW,GAAa,CAC5C,EAAS,WAAW,KAIpB,EAAS,uBACX,EAAK,iBAAiB,UAAW,GAAa,CAC5C,AAAI,EAAU,MAAM,cAAgB,iCAClC,EAAS,4BAKX,EAAS,qBACX,EAAK,iBAAiB,UAAW,GAAa,CAC5C,GAAI,EAAU,MAAM,cAAgB,oBAAqB,CACvD,GAAM,CACJ,WACA,KAAM,GACJ,EAAU,KACd,EAAS,sBAAsB,EAAe,ODrBtD,GAAM,GAAa,CAAC,EAAgB,EAAgC,KAClE,GAAI,SAAQ,CAAC,EAAS,IAAW,CAC/B,GAAI,IAAW,IAAK,CAClB,EAAO,yEACP,OAIF,OAAO,iBAAiB,UAAW,GAAe,CAChD,GAAI,EAAY,MAAM,cAAgB,0BAA2B,CAC/D,GAAI,EAAY,SAAW,EAAQ,CACjC,EAAO,4DACP,OAGF,GAAM,GAAO,EAAY,MAAM,GAG/B,EAAe,EAAM,GAErB,EAAK,QAGL,EAAK,YAAY,CAAE,YAAa,6BAUhC,EARuC,CACrC,OACA,qBAAsB,IAAM,EAAK,YAAY,CAC3C,YAAa,6BAEf,WAAY,IAAM,EAAK,aAO7B,OAAO,OAAO,YAAY,CACxB,YAAa,wBACb,WAAY,OAAO,MAClB,GAGH,WAAW,IAAM,CACf,EAAO,0CACN",
  "names": []
}
